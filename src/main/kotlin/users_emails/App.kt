/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
@file:JvmName("App")

package users_emails

import java.util.*

class ParseError(val wrongRecord: String): Exception()

fun parseRecord(str: String): Pair<String, Set<String>>
{
    try {
        val (name, addresses) = str.split(" -> ")
        val emailAddresses = addresses.split(",").map(String::trim).toSet()
        return Pair(name, emailAddresses)
    } catch (ex: Exception) {
        throw ParseError(str)
    }
}

const val HELP_MSG = "Record should look like email -> email1@.com, email2.com"

fun main(args: Array<String>) {
    try {
        val emailsForName = generateSequence { readLine() }
            .map(::parseRecord)
            .associateBy({ (name, _) -> name }, { (_, emails) -> emails })
        groupUsers(emailsForName).forEach { (name, emails) ->
            println("$name -> ${emails.joinToString(", ")}")
        }
    } catch (e: ParseError) {
        error("Invalid user record ${e.wrongRecord}. $HELP_MSG")
    }
}

fun groupUsers(
    emailsForName: Map<String, Set<String>>
) : Map<String, Set<String>>
{
    val namesForEmail = emailsForName
        .entries
        .asSequence()
        .flatMap { (name, emails) -> emails.asSequence().map { Pair(name, it) } }
        .groupBy({ (_, email) -> email }, { (name, _) -> name })
    return findConnected(
        namesForEmail = namesForEmail.mapValues { it.value.toMutableSet() }.toMutableMap(),
        emailsForName = emailsForName.toMutableMap(),
    )
}

private fun findConnected(
    namesForEmail: MutableMap<String, Set<String>>,
    emailsForName: MutableMap<String, Set<String>>,
): Map<String, Set<String>>
{
    val connected = mutableMapOf<String, MutableSet<String>>()
    while (emailsForName.isNotEmpty()) {
        val knownNames: Queue<String> = LinkedList(emailsForName.keys.take(1))
        val mainName = knownNames.first()
        while (knownNames.isNotEmpty()) {
            val name = knownNames.poll()
            val emails = emailsForName.remove(name) ?: setOf()
            connected.getOrPut(mainName) { mutableSetOf() } += emails
            for (email in emails) {
                knownNames.addAll(namesForEmail.getOrDefault(email, setOf()))
            }
        }
    }
    return connected.toMap()
}